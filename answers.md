### Ques: How long did you spend on the coding test below? What would you add to your solution if you had more time? If you didn't spend much time on the coding test then use this as an opportunity to explain what you would add.

__Res__

I spent close to 18 hours on this project.
If i had more time, i would add :

- Add and display Audit Logs.
- I would expand the meta column into his own set of tables where a table would exist holding the values of all keys and users can select from there, while the values selected or entered would be saved in another table with a FK referenicing the key that corresponds to them. Also for the enum types it would have its own table for values choosen for it making it possible for it to expand as much as possible.
- Implement pagination on the front-end (JS)
- Unit Tests for both frontend and backend.

### Ques: What was the most useful feature that was added to the latest version of your chosen language? Please include a snippet of code that shows how you've used it

__Res__ :

String Interpolation in JS (ES6) : `apiBaseUrl: ${process.env.VUE_APP_BACKEND_URL}/api/v1`

Block Scoped functions in JS (ES6) :
```
mutations: {
    setFavoriteThings: function (state, payload) {
      state.favoriteThings = payload;
    },
    setCategories: function (state, payload) {
      state.categories = payload;
    }
  }
```

### Ques: How would you track down a performance issue in production? Have you ever had to do this?

__Res__ : 
Yes, we had a query which was taking too long to return values, it took close to 10 mins to return a result, which wasn't meant to be so. the query was a little big it had a sub-query to match results based on a pattern and up to 4 *AND (&&)* operations basically to give time constraints. So the first thing i did was to get the raw query generated by our ORM (Eloquent). What i did here was to log the query and then copied that query and ran it on Sequel Pro with *DESCRIBE* so i can see how long it takes. The plan time was short but the execution time was on a greater side. so i decided to break the query in to single units and use *EXPLAIN ANALYZE* on each of them. It showed that there were multiple rows of *&&* filters which weren't jsut expensive operations but they ran multiple times.
